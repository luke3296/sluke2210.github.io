<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="/_assets/main.css" />

    <title>Programming 2 - notes</title>
  </head>
  <body>
    <div class="main">
      <nav class="navigation">
        <a href="/">notes</a>
      </nav>
      <article>
        <header>
          <h1 class="article-title">Programming 2</h1>
          <div class="article-info">
            <div>
              <span
                >Created At：<time datetime="1616423740419"
                  >2021-03-22 14:35</time
                ></span
              >
              <span
                >Updated At：<time datetime="1616423752125"
                  >2021-03-22 14:35</time
                ></span
              >
            </div>
            
          </div>
        </header>
        <div class="article-content markdown-body"><p>Key differeces between java and C:</p>
<p>Java is designed for portability while C is designed for systems programming.<br />
Java hides differences in through the JVM<br />
C exposes differerences in hw thtough numeric types</p>
<p>Java is OO while C is procedural.</p>
<p>Java has strong typ checkings and garbage collection to help stop errors.</p>
<p>C places more reposobility of the programmer. Java is a decendednt of C.</p>
<p>#include &lt;stdio.h&gt;<br />
#include &lt;stdlib.h&gt;<br />
int main(int argc,char** argv)<br />
{<br />
printf("Hello World!\n");<br />
return EXIT_SUCCESS;<br />
}</p>
<p>Consider the hellowworld.c above; The macros defined in stdlib.h (EXIT_SUCCESS and EXIT_FALIURE) are interger values defined for greater portability.  We must return a value to the os.</p>
<p>Unlike java , C is complied into excutable files.</p>
<p>(Source.c)  -&gt;  preprocessor  -&gt; complier -&gt; (object file) --&gt; Link --&gt; executable.<br />
^                                          ^<br />
|                                          |<br />
headers.h                                    C libaries</p>
<p>Pre-processor:performs various textual transformations of the source code.</p>
<p>Compiler:Translates source code into object code.</p>
<p>Links together object code from compiler and from libraries to form executable program.</p>
<p>Like Java, C has extensive standard libraries to avoid “reinventing the wheel”.</p>
<p>Entities contained in the libraries are declared in header files.</p>
<p>staments prepended with #are for the preprocessor, e.g #include &lt;somelib.h&gt; will coppy the osurce code from the somelib header file and past it in place of #include &lt;somelib.h&gt; before compilation.</p>
<p>&lt;stdlib.h&gt; contains many standard c i/o methods like printf() and scanf().<br />
for structured output and input respectivly.</p>
<p>printf("hello to all you %i people\n" , 10);</p>
<p>scanf("(%i,%i)", &amp;a, &amp;b)  - reads two ints in brackets seperated by commas. inta -&gt; &amp;a where &amp; means "the address of"</p>
<p>C pointers vs Java References</p>
<p>C pointers are varibles that references a physical memory location in ram. It is an interger.<br />
References are abtract methods that returns the location of a varible in the JVM's memory. We can rearange the heap to remove small amounts of free space between objects on the heap. The garbasge colector only has to move one reference per object loop. It modern JVM's a reference may be implemented directoly allowing them to be used like pointers. No matter how ponters are implemented in java its connection to the physical machine is abstracted away.</p>
<p>Pointer arithmatic is important because aray accsess in C is implmented using pointer arithmatic.And array is the pointer where an object is stored and the index is also just a number.</p>
<p>Malloc is a command in the standar lib used to allocate a block of memory from the heap. It returns the pointer to the memory we allocated. Free we pass a pointer, and free will free that memory again. Each block has a header imidiatly before it that stores wether its free or not and how bit the block is. We can use pointer aithmatic to find the header of the current block and adjacent block in memory. Malloc returns a pointer to the first free part of the block after the header.</p>
<p>A bool in c is not a numeric type. java uses 16 bit chars while c isnt designed for such portability. C char is 8 bits ascii.</p>
<p>c interger types are signed by defult however the implemnetation varies, usualy twos complement. Java only allows u to create signed intergers but in c u can make unsigned ints with the unsigned modifier.</p>
<p>unsigned int a;</p>
<p>chars can be signed and unsigned whitch it is is compiler dependent. a whcar_t reperesnts 'wide characters' outside of ascii such as unicode. _t signifies its a type. size_t is a type that can store the largest object in ur program.</p>
<p>stdint.h defines a range of interger types with predefined types</p>
<p>signed : int8_t int16_t int32_t<br />
unsigned: uint8_t uint16_t uint32_t</p>
<p>In c true and false are defined by nonzero and zero respectivley. This lets arithmetic expressions be interpreted as boolean, say in an if condiditon.</p>
<p>float.h defines some useful constants such as FLT_MIN and FLT_MAX are the smallest and largest values a float can store. If we start a number with 0 it is read as octal in c.</p>
<p>unsigned long x = 245ul ; the ul tells the compiler 254 should be read as an unsigned long.<br />
use unsigned ints when the value can't possibly be negative e.g counting.<br />
use int as the default interger type.Do not use char or bool in arithmetic expressions. Use double when you have fractional values.</p>
<p>C has the same arithmetic operators as Java. += was shorthand to hint to the compliler to use the add and accumulate oppcode. However modern compilers can do all this.<br />
*, / %, + - ; most  operaators are left associative. Assignment is right associative.</p>
<p>C has operators for binary data</p>
<p>&amp; and and | or<br />
^ bitwise xor<br />
~ bitwise not</p>
<blockquote>
<blockquote>
<p>&lt;&lt; bitwise shift right and shift left.</p>
</blockquote>
</blockquote>
<p>&amp;&amp; and || only excute the second argument in the first arument is true or false respectivly. c has less type checking than java. 'A' will be implicitly converted to 65 from char to int if added to a number.</p>
<p>int x = 'A' + 3.1416926 -2; it will be fine with this. -all will switch on all warning in a c compiler. const is a modifier to create a read only varible in c. Global varibles are initalized to 0 while local varibles are uninitlised.</p>
<p>c also has the ternary operator.<br />
<expression class="jop-noMdConv"> ? <expression1 class="jop-noMdConv"> : <expression2 class="jop-noMdConv"><br />
if true     expression 1   else   expression 2</expression2></expression1></expression></p>
<p>adopt a neutral sober tone (not fliippent) in out communications with the user.  break means exit the loop and continue after the loop. continue means go back to the top of the loop.</p>
<p>Java varibles can store wither primitives or the reference to an object. A reference may point to null. Java was designed to be small but with a large standard library. In java a reference is the memory location in the JVM of a particular object.</p>
<p>C is a simpler language , a varible can hold 1 of 4 things. A primitive value , An array, a user defined type (stuct or union), a pointer to another varible. A java refrenece is basically the same as a c pointer except C pointetrs can point to a primitive varible and arithmetic can be performed with c pointers as  they reresent phyical memory locations on the computer.</p>
<p>pointer to a primitive data tyoe:</p>
<p>int x = 42;<br />
int *xPointer = &amp;x;</p>
<p>Here xPointer is a pointer to an intm &amp;x can be read as 'the address of' x.</p>
<p>int y = *xPointer;</p>
<p>this makes an interger y that is the thing pointed to by pointer *xPointer e.g 42.</p>
<p>you can define pointers either like:</p>
<p>int* x = &amp;y; || int *x = &amp;y;</p>
<p>though we should stick to the second. More than one var may be declared at a time.<br />
int *px, py, **pz;</p>
<p>Synchronus remote lecture. Testing stratergies.</p>
<p>Unit testing is setsting one subsystem or module of a program in isolation, eg a particular function or class. In system testing we intergrate all component together to see if they work correctly as a whole program. We used to manuel testing, a sucsessful test is one that reveals a bug. You should try all sorts of inpuut and think about what might break a fucntion/class.</p>
<p>Automated testing is recorded and repeatble. We write a test harness that does the tests for us.<br />
Property based testing has an assertion garatueed to be true for our code to be correxct. Test driving development starts with prototype code, then we write tests and go back to the code improve it untill it passes the test. this is TDD.<br />
Java has Junit a framework for writing test harnesses.</p>
<p>in c arrays are allways passed by reference to increase efficheny. Primitive data types are coppied unless we are getting data back out of them. There is no efficheny increase with passing references to primitive data types. When the compiler sees ... to mean varargs it will convert float to doubles.</p>
<p>Lecture 3</p>
<p>The new operator returns the numeric refrecne in the computers memory where you can find that object.</p>
<p>Lecture 5<br />
C provides &lt;stdio.h&gt; for stream based i/o, it supports text files devided into lines, binary files as a sequence of bytes. C allows you to accsess files directly or sequentially. Direct accsess means we can read / write to a specified location in a file. Files are accsessed  by having a pointer to a file descriptor. We can use fopen('filename.txt', 'r') the second aregument specifies what accsess mode we want to use e.g 'r' opens in read mode. If fopen returns a null pointer then it failed to find a file with that filename.</p>
<p>FILE *input = fopen('./some/text.txt', 'r');  --access via a pointer to a FILE discriptor of fd.<br />
input == NULL if files doesnt exsist.<br />
FILE *output= fopen('./some/path', 'w');<br />
we can use fgetc with out File discriptor to get a character from a  file one char at a time untill a EOF. fputc puts a char on a file. We should use fclose(FILE DISCRIPTOR (input &gt; output) ) to released the file.</p>
<p>accsess modes:<br />
r - Open an exsisting file for input.<br />
w - create or truncates output to an exsisting file.<br />
a - Create a new file, or appened to exsisting for output.<br />
r+ - Open an exsisting file for update (r+w) start at the begginging of the file.<br />
a+ - Create a new file, or appened to and exsisting one for update.<br />
w+ - Create a new file, or trucates to and exsisting one for update.</p>
<p>truncating a file will wipe the file each time while appending appends to the end.</p>
<p>fprintf allows you to print a specific stream. fprintf has a first argument of the file discriptor you wish to write to. Streams are automatically buffered for effichency. The buffer can be emptied using fflush();  The buffereing can be modified using setvbuf. A stream can be unbuffered like stderr. Fully buffered which flushes buffer when full. Line buffer witch flushes buffer on newline. ungetc(char, stream) pushes a char back into a stream. fprinf returns an int whitch is the number of chars susessfully read from the input stream. The ... show that fprinf is a vararg fucntion. There are many conversions you can do for formating outputs. left justify is -. Minimum filed width ad precisons.</p>
<p>printf relies on the format string to decipher the stack (its stack) printf then goes through the format string to find out how many other chracters it should find on the stack fram. It will then go look for them and interpret the block of memory the way its been written in the format string.</p>
<p>We can use fscanf to read from a stream, likw the keyboard or a file. It will keep reading unitll it finds something that matches its format string. It returns the number of conversions it done susessfully. A single white space in the format string will be mapped to any number of whitespace chars in the input. %[] limited regex. * will allow you to ignore certain patterns. Strings in c are null terminated char arrays.</p>
<p>Prepossessing directives: in C</p>
<p>there is a ritc set of c preprosessor directives. a preporcessor performs textual translation of our source code.<br />
#include -&gt; selectivly include a specific file<br />
#define -&gt; creates symbolic constants and macros<br />
#ifdef &amp; #endif -&gt; selectivly include/exclude source code<br />
#pragma give the compiler hints</p>
<p>#include -&gt; one filed is coppied verbatium into another files and the preprocessor is run again. &lt;&gt; standard libaries where as "" signifies our own header files.</p>
<p>#define is used to make textual subsitutions. One use is defineing symbolic constants like<br />
#define AVAGADRO (6.022E23);<br />
This subsistutes AVAGADRO with 6.022E23 where ever it appears in tthe file. We can form expressions too.</p>
<p>We can define one constant in terms of others and the preprocessor will be rerun.</p>
<p>#define can also take parameters , its a little like a function but it is not complied mearly coppied everywhere it is used in the file. consider the following:</p>
<p>#define CALLOC(n,type) ((type*)calloc(n, sizeof(type)))</p>
<p>now we can make arrays like:</p>
<p>int *myIntArr = CALLOC(1024, int);</p>
<p>the arguments will be passed by the macro into the type cast and arguments to calloc and coppied in place of the CALLOC statement.</p>
<p>There is no typechecking with macros. the compiler does typechecking on the substituted text. SWAP macros are popular.  In c++ there a typesafe method for doing this called templates. Be careful with putting semi colons after macros. If we have paramters that are expressions not single varibles the expansion can lead to bidmas / precendence errors.</p>
<p>If the evaluation of the agument has side effects e.g pre/post incrmeent can cause errors too. Remember it only does textual translation, no compilation.</p>
<p>multiple increments of the same varible with the same expression are not defined by the c standard and so are platform specific. this mean we can run in to portability errors.</p>
<p>Avoid arguemtns with side effects in macros.<br />
The C preprocessor has some default macros. such as:<br />
<strong>LINE</strong> the current line number in the src.<br />
<strong>DATE</strong> the date of complilation<br />
<strong>TIME</strong> the time of complilation<br />
C versions etc.<br />
This can be useful for printing error msgs.</p>
<p>We can also use the preprocessor to on the fly include / exclude debugging code.<br />
#Define DEBUG 1 -&gt; defines our debugging status</p>
<p>#if DEBUG<br />
debug code<br />
#else<br />
normal code<br />
#endif -&gt; closes the #if block</p>
<p>this can be useful for comenting out large blocks of code safely. We can do the same thing with multiple debug states. e.g<br />
#define DEBUG_STRONG 2<br />
#define DEBUG_WEAK 1<br />
#define DEBUG_OFF 0</p>
<p>#define DEBUG == DEBUG_STRONG</p>
<p>#if DEBUG == DEBUG_STRONG</p>
<p>#elif DEBUG == DEBUG_WEAK</p>
<p>#else</p>
<p>#endif</p>
<p>avoid nested preprocessor directives.</p>
<p>size_t in a size in c that stores the size of the biggest array you could make.<br />
a c++ pointer in the same as a java reference.</p>
<p>nested classes threads and generics</p>
<p>in java:</p>
<p>we can 'type' a class and make it generic by adding a capital letter representing the type or atgument the class holds after the class header deffinition</p>
<p>public class Pair&lt;V,K&gt;{}</p>
<p>public class Wrapper<e class="jop-noMdConv">{</e></p>
<p>}</p>
<p>creates a Wrapper generic class that can only be instaciated with objects that inherit from Number. Note that this extends is different from normal class inheritence , it the genric class the extends bounds what types can be put in the class. when written at the end of a class header e.g</p>
<p>public Double extends Number implemnts Serialisable , Comparable<double class="jop-noMdConv"></double></p>
<p>means the class Double inherits attributes and methods of  Number and implemnts the serialisable and Comparable interfaces. I can put a Double in in class Wrapper because the type E extends Number and a Double inherits from Number.</p>
<p>We can also type methods by putting the generic indtetifer before the return type of the function.</p>
</div>
      </article>
    </div>
  </body>
</html>
