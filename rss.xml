<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title></title>
        <link>undefined</link>
        <description>undefined</description>
        <lastBuildDate>Sat, 25 Feb 2023 17:47:21 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Joplin Pages Publisher</generator>
        <item>
            <title><![CDATA[N tile]]></title>
            <guid>1ac987e2fb0e42578339f324da959d10</guid>
            <pubDate>Sat, 25 Feb 2023 17:08:15 GMT</pubDate>
            <content:encoded><![CDATA[<p>N tile</p>
<p>The N tile is a simple game where you have a grid of blocks with one blank, you move the blank around and in the process generate diffierent configuratiosn  of the blocks in the grip.</p>
<p>Chrismass crackers oft contain a 3-puzzle or 4-puzzle with a chirmass themed picture on it as a prize.</p>
<p>You can check if a n puzzle is solvable by counting the number of inverions in the initial state. If its even the puzzle is solvable, if its odd the puzzle is unsolvable.</p>
<p>transistions or moves involve sliding a block into the postition of the blank, though in practice it's easier to think of moving the blank around the board.</p>
<p>Consider this example where the blank is represneted as a 0.</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>there are two pssible transistions from this state, you could slide the 1 tile left ot the 3 tile up yielding the sucsessors</p>
<table>
<thead>
<tr>
<th>1</th>
<th>0</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>3</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
</tbody>
</table>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Agents ]]></title>
            <guid>04b52c788e284e5e911c0dfdbff04794</guid>
            <pubDate>Sat, 25 Feb 2023 16:46:38 GMT</pubDate>
            <content:encoded><![CDATA[<h1 id="agents">Agents</h1>
<p>An agent is anything that acts. It can be a piece of software or purley conceptual. we can model differnet types of agents to perfrom different types of tasks.</p>
<ol>
<li>Agents are automnous / semi autommous meaning they are able to act without perfect knowledge of the enviroment</li>
<li>Agents are situated in an enviroment (where enviroment is anything that isn't the agent including other agents in multiagent systems) an can perceive some of its enviroment</li>
<li>Agents are iterational with other agents forming a soceity of agents that can work on aparticular task</li>
<li>the society of agents is structured. that is each agent perfomrs one specific task using its own perception of enviroments and its own set of actions. It works with other agents in a sructured way to perform problem solving</li>
<li>Intelegence is an emergent effect that can come out of the iteractions of a society of agents.</li>
</ol>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Infromed search]]></title>
            <guid>5d5becad927a4d17a11f7f38d7397817</guid>
            <pubDate>Sat, 25 Feb 2023 16:46:19 GMT</pubDate>
            <content:encoded><![CDATA[<h1 id="infromed-search">Infromed Search</h1>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Uninformed search]]></title>
            <guid>2a01556bd77243cdb9d406141b990156</guid>
            <pubDate>Sat, 25 Feb 2023 16:45:56 GMT</pubDate>
            <content:encoded><![CDATA[<h1 id="uninformed-search">Uninformed Search</h1>
<p>we will use the N tile puzzle as an example<br />
find a disrecption of the ntile here<br />
<a href="/article/n-tile">N tile</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AI - intro]]></title>
            <guid>7db4a6d1738b415187e24c47656fd582</guid>
            <pubDate>Sat, 25 Feb 2023 15:29:36 GMT</pubDate>
            <content:encoded><![CDATA[<p>AI is a field  with a lot of histroy and lot of applications. Many techniques such as state space search grew out of attempts in AI to make intellegent programs. Thinking about thinking is a difficult task as you cannot remove yourself from the thought process. Yet many AI programs take there inspiration from human resoning processes. There are three ways we can think about how humans think</p>
<ol>
<li>Introspection - trying to catch our own thoughts as they go by</li>
<li>phycoogy experiments - by observing other people and how they act in an expereiment</li>
<li>brain imageing - there by observing how the brain responds to certain stimuli and</li>
</ol>
<p>More broadly the field of cognative science uses AI techniques as well as traditional science to try uncover the inner workings of intellegence.</p>
<p>my personal  view is that intellgence is a emergent effect of sufficechntly complex systems with a goal and exsists on a spectrum . For example a dog is intellegent but<br />
There have been many attempts to make intellegent programs but the holy grail of AGI is still out of reach. Some of these techniques include</p>
<ol>
<li>logic based approaches - use rules of logic as to solve a problem stated in logical notation. This technique has traditionally domniated as we view logic as an essential part of intelegence itself. These can also thought of as 'rationalist approaches'.</li>
<li>evoltionary approaches - create a generation of programs that can repoduce themselves keeping desireble traits while undesireble traits 'die out'. The idea being that natruel selection applied to programs can bring about intellegence. They use genetic algorithms</li>
<li>connectionist approaches that try to understand intellegence through the connection of nurons. The predominat work in the field is the mapping of the conectome of C elegans.</li>
<li>Agent based approaches, modelleing intellegence through the interactions of a sociaety agents in the hope that they are more intellegent than the sum of there parts</li>
<li>others...</li>
</ol>
<p>More recently techniques in Machine Leanring have been applied to AI problems such as computer vision and Natruel langugae processing. These are invaluvble techniques in the contruction of an otellegfent systems. Deep nural networks can be used as blackboxes that perfrom complex function for example turning images into textual representatations and vis vera. DNN's are determinist in the sense that provided with the same input they will produce the same result. I beleive a truly intellegent program would have to include some stochatic process otherwise there just very impressive mappings.</p>
<p>The first logic based approaches automated theorm solvers<br />
<a title="https://en.wikipedia.org/wiki/Automated_theorem_proving" href="https://en.wikipedia.org/wiki/Automated_theorem_proving">https://en.wikipedia.org/wiki/Automated_theorem_proving</a><br />
which are pretty  cool.</p>
<p>Links:</p>
<p>uninformed state based search : <a href="/article/uninformed-search">Uninformed search</a></p>
<p>joplin://x-callback-url/openNote?id=04b52c788e284e5e911c0dfdbff04794</p>
<p>informed state based search : <a href="/article/infromed-search">Infromed search</a></p>
<p>agents : <a href="/article/agents">Agents </a></p>
<p>Ref : Artificial Intellligence A moderd approach , 3rd edition, by Stuart Russell and Peter Norvig ,  page 1- 8</p>
<p>Ref : Artificial Intellligence Structures and Statergies for Complex Problem Solving , sixth edition by George F Luger chapter 1</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Intro to ML]]></title>
            <guid>401ae5679a0640c1aaa705e4dacc7aaa</guid>
            <pubDate>Tue, 01 Nov 2022 09:10:50 GMT</pubDate>
            <content:encoded><![CDATA[<h1 id="intro-to-ml">Intro to ML</h1>
<p>machine learning is a branch of Artifical intelegence concerned with algorithms that use data to tune the algorithms paramters in order to increase its accuracy when run on new unseen data. AI is the branch of computer science that aims to explore intelegince though the lense of computer science and delevop algorithms that simulate human dession making processes.</p>
<p>Machine learning has two main objectives.</p>
<ol>
<li>to pridict the class of unobserved data / cluster data into relevant groups</li>
<li>to explore relations between attibutes in data that may help to explain observed relations in real world phenoma.<br />
e.g given some data on covid 19 cases<br />
Pridiction: Can we predict whether someone with COVID will fully recover or get long COVID?<br />
Explain relation: Why do people get long COVID? Is it a function of other factors such as enviroment.</li>
</ol>
<p>an instance  or case  or record  referes to the data corrospondong to 1 observation. e.g each row is usually an instance.</p>
<p>a class variable is the varible that the algorithm endevours to classifiy based off the other varibles. The other varibles are often called attributes.</p>
<p>The attributes can be:<br />
binary, i.e 1 or 0, on or off, hot or cold, posative or negativebox<br />
real valued,  i.e tempterature, windspeed, height<br />
ordinal, i.e,   Age-group, Height-group<br />
discrete set of independed satstesm i.e, colour</p>
<p>if a problem has the a</p>
<h2 id="descison-tree">Descison Tree</h2>
<p>Descison Trees are a familiy of algorithms that aim to classifiy unseen data by using a set of simple rules that follow on from one another in a tree structure. DT's</p>
<h2 id="ensemble-methods">Ensemble Methods</h2>
<h2 id="evaulating-dts">Evaulating DT's</h2>
<h2 id="k-nearest-neighbour">K-Nearest Neighbour</h2>
<h2 id="linear-classifiers">Linear Classifiers</h2>
<h2 id="support-vector-machines">Support Vector Machines</h2>
<h2 id="artifical-nural-networks">Artifical Nural Networks</h2>
<h2 id="clustering">Clustering</h2>
<h2 id="reinforcment-learning">Reinforcment Learning</h2>
<p>reinforcemnt learning is a problem faced b an agen through trail-error interactions with its enviroment.<br />
it contrasts machine leanrning where past data is used to fit a model.<br />
reinfrocment learning is learning from experinennce to associate states and actions with desred outcomes.</p>
<p>An agent makes a descion based on its enviroment. The evviroment may change as a result and the eviroment gives the agent a hueristic about how 'sucsessful' the previous action was.</p>
<p>The feedback huristic can be used to adjust the decsion made incase if faces the same descion in the future.<br />
enviroment:<br />
S = {s1,s2,s3,s4,s5}<br />
actions:<br />
A={a1,a2,a3,a4,a5}</p>
<p>for any state action pair (S, A) he agent recives a reward signal from the enviroment</p>
<p>r: SxA -&gt; Reward<br />
this is a numerical signal that quantifys how well the agent is doing at meeting its objective</p>
<p>The agent percieves a sequence of states and performs a sequenc of actions. The agent chooses an action based on a descion making stratergy or policy.<br />
it could be a mapping of states to actions<br />
or it could be a probablistic model</p>
<p>the agents objective is to choose a stratergy that maximises some function of the total reward it reieves.<br />
the agent may try and discover the policy that maximises total reward.</p>
<p>its difficult because</p>
<ol>
<li>the learning is unsupervised. if the agent reciecves a reward, it has no idea of finding out if a different action would have yilded a better reward.</li>
<li>there is usully uncertinity in the reward, its hard to learn a rule from a random varible. the reward function itself can change over time</li>
<li>learning is online and bad decsions have nagative consequnces. each case counts owards meeting the goal and the agent must balance the need to explore with the need to explot.</li>
<li>rewards can be delayed.</li>
<li>actions influence future states</li>
</ol>
<h2 id="learning-classifier-systems">Learning Classifier Systems</h2>
<h2 id="time-series-classification">Time Series Classification</h2>
<h2 id="issues-in-ml">Issues in ML</h2>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AP]]></title>
            <guid>39e48a5cad74411fa19968731f9b66fc</guid>
            <pubDate>Tue, 27 Sep 2022 13:04:52 GMT</pubDate>
            <content:encoded><![CDATA[<p>timis# project log</p>
<h2 id="week-1">week 1</h2>
<ul>
<li>project 1 sailor jargen to mini c (no macros or structs) OR project 2 plot functions of the for y = f(x) or z = f (x, y)</li>
</ul>
<p>1x^1 + 2x^2 - 2x^3</p>
<ul>
<li>sign 0<br />
1x coeeficent 1<br />
^1 power 2<br />
( 3<br />
) 4</li>
</ul>
<p>1x^1 + 2x^2 - 2x^3</p>
<p>symtable<br />
[0, 1, 1, 0, 2, 2, 1, 2, 3]<br />
token-table<br />
[0, 1 , 2 , 0, 1 ,2, 0, 1, 2]</p>
<p>1 1 + 2 2 - 2 3<br />
poly = len<br />
[1,2,3] coefficent<br />
[1,2,3] power<br />
[1,1,0] sign</p>
<p>[-10 .. 10] input<br />
[] output</p>
<p>for x in input:<br />
for<br />
written some BNF to represent the polynomial and defined the interger id's for the tokens in lexer.fs</p>
<p>//BNF Rules<br />
&lt;digit&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9<br />
&lt;int&gt; ::= &lt;digit&gt; | &lt;digit&gt; &lt;int&gt;<br />
&lt;term&gt; ::= &lt;int&gt; | &lt;int&gt;x | &lt;int&gt;x^&lt;int&gt;<br />
&lt;poly&gt; ::= &lt;term&gt; + &lt;term&gt; | &lt;term&gt; - &lt;term&gt; | &lt;term&gt; + &lt;poly&gt; | &lt;term&gt; - &lt;poly&gt;</p>
<p>and example parse tree for the input string<br />
1 + 2x - 3x^2 + 4x^3 - 5x^4</p>

				<div>
					
					<pre class="mermaid">graph TB;
    poly--&gt;term1[term];
        term1--&gt;int1[int]
        int1--&gt;terminal1[1]
        poly--&gt;sign1[+]
        poly--&gt;poly1[poly];
 	 poly1--&gt;term2[term]
     term2--&gt;terminal2[2x]
     poly1--&gt;sign2[-]
     poly1--&gt;poly2[poly]
     poly2--&gt;term3[term]
     term3--&gt;terminal3[3x^2]
     poly2--&gt;sign3[+]
     poly2--&gt;poly3[poly]
     poly3--&gt;term4[term]
     term4--&gt;terminal4[4x^3]
     poly3--&gt;sign[-]
     poly3--&gt;poly4[poly]
     poly4--&gt;term5[term]
     term5--&gt;terminal5[5x^4]





</pre>
				</div>
			<p>The project we will be doing is project one.<br />
a source program written in our own language and compiled into a c binary.<br />
there may or may nor be an intermidiate pascal layer</p>
<h2 id="pascal-bnf">pascal bnf</h2>
<p><program class="jop-noMdConv">::= Program <id class="jop-noMdConv">( <id class="jop-noMdConv">) ; <block class="jop-noMdConv">.<br />
| Program <id class="jop-noMdConv">( <id class="jop-noMdConv">, <id class="jop-noMdConv">) ; <block class="jop-noMdConv">.</block></id></id></id></block></id></id></program></p>
<p><id class="jop-noMdConv">::= letter letter<br />
| letter digit<br />
| letter</id></p>
<p>&lt;unsinged_interger&gt; ::= digit<br />
| digit</p>
<p><block class="jop-noMdConv">::= begin <statment class="jop-noMdConv">end</statment></block></p>
<p><statement class="jop-noMdConv">::= begin <statment class="jop-noMdConv">end<br />
| if <expression class="jop-noMdConv">then<statement class="jop-noMdConv"><br />
| if <expression class="jop-noMdConv">then <statement class="jop-noMdConv">else<statement class="jop-noMdConv"><br />
| while <expression class="jop-noMdConv">do</expression></statement></statement></expression></statement></expression></statment></statement></p>
<p><expression class="jop-noMdConv">::= &lt;simple_expression&gt;<br />
| &lt;simple_expression&gt; &gt; &lt;simple_expression&gt;<br />
| &lt;simple_expression&gt; &lt; &lt;simple_expression&gt;<br />
| &lt;simple_expression&gt; &lt;= &lt;simple_expression&gt;<br />
| &lt;simple_expression&gt; &gt;= &lt;simple_expression&gt;</expression></p>
<p>&lt;simple_expression&gt; ::= +<term class="jop-noMdConv"><br />
| -<term class="jop-noMdConv"><br />
| + <term class="jop-noMdConv">-<term class="jop-noMdConv"><br />
| + <term class="jop-noMdConv">+<term class="jop-noMdConv"><br />
| - <term class="jop-noMdConv">+<term class="jop-noMdConv"><br />
| - <term class="jop-noMdConv">-<term class="jop-noMdConv"><br />
<term class="jop-noMdConv">::=<factor class="jop-noMdConv"><br />
| <factor class="jop-noMdConv">*<factor class="jop-noMdConv"><br />
| <factor class="jop-noMdConv">/<factor class="jop-noMdConv"><br />
| <factor class="jop-noMdConv">div<factor class="jop-noMdConv"><br />
| <factor class="jop-noMdConv">mod</factor></factor></factor></factor></factor></factor></factor></factor></term></term></term></term></term></term></term></term></term></term></term></p>
<p><factor class="jop-noMdConv">::= &lt;unsigned_constant&gt;<br />
| ( <expression class="jop-noMdConv">)</expression></factor></p>
<p>&lt;unsigned_constant&gt; ::= &lt;unsinged_number&gt;<br />
&lt;unsinged_number&gt; ::= &lt;unsinged_interger&gt;</p>
<p>As non left recursive:</p>
<p>No longer doing eso_lang. now only doing a pascal compiler</p>
<p>Revision:</p>
<p>Lecture 5 parallel computing.</p>
<p>Paralell programming also know as high performance computing is becoming increasingly important and concerns writing programs that can make the most of the resources given to it. For example many programs accelerate computation of some task in the program by performing it on the GPU</p>
<p>Amdahls law</p>
<p>In words: the effect of imporving the speed of a part of the system, on the overall system, depends on the signinfigance of the part and its speed up.</p>
<p>Assume we have an application that takes time T_old on a certain system  of which a fraction alpha of the total time is sped up with a factor k.</p>
<p>(1) T_new = (1-alpha)T_old + (alpha*T_old)/k</p>
<p>its almost like a linear interpolation accept we devide by k. where alpha is the fracton of speed up and k is the speed up factor.</p>
<p>we can rewrite (1) by factorising T_old out</p>
<p>T_new = T_old((1-alpha) + alpha/k)</p>
<p>T_new/T_old = (1-alpha) + alpha/k)</p>
<p>S = speedup = T_old/T_new = 1/((1-alpha) + alpha/k)</p>
<p>Assume a program component contributes 6-% of the total time as in sped up by a factor of 3. The over all speedup is/</p>
<p>1/(1-0.6 + 0.6/3)  = 1.6666</p>
<p>so the speed up is 1.67. less than you might expect. can be ead up as you have sped up 60% of the og problem by a factor of 3. In the sense hear the 60% can be sped up corssosponds to what can be paralellised. Hoever this also works with optimisation.  When k -&gt; infinte the speed up s 2.5 for the case where 60% is paralellizable.</p>
<p>Parallelism is common in nature and society.</p>
<p>serailistionis the aact of putting a set of operations in specific sequential order.</p>
<p>Serialisation is now in desprate need of revsion due to the increasing paralell nature of modern day processors.</p>
<p>Modern programming languages and tools still suffer from serial traps. i.e construction makes often unnecessary serial assumptions.  To avoid these traps we muct learn to think paralell an learn how to recognise serial traps.  Parallel algorithms are constraind by the algorithms span. The part of an algorithm that cannot be paralellised is called the span. the span is the processing time of the longest sequence of tasks that must be performed serially.</p>
<p>The span determins the limit of how fast a paralell algorithm can run. Another bottle neck with regaurds to Per preocessor performance is memory action.</p>
<p>shared memory is conveient but may have communication costs based on the relative location of the each processor.</p>
<p>span is also known as the critical path. mutex's and semaphores are used for communication. they slow the parallelism down. Total time to complete a task is called the latency. the rate at which a series of tasks can be computed is the throughput.  For big systems the power consumption becomes important.</p>
<p>Speedup related the latency of one hardware nuuit or 'worker' versus p workers.</p>
<p>S = T1 / Tp</p>
<p>Where T1 is the latence of one worker and Tp is the latency of p workers.  Effichency is speed up devided by number of workers.</p>
<p>E= S/P = T1/TP*P</p>
<p>An alogrithm that runs p times faster on p processirs is said to exhibit linear speedup.it's rarley ahcieves usually we have a sub linear speedup. However occasionally super linear speedup is achieveble when the task is more effeichent using a paralell algorith.</p>
<p>power consumption is proportionl to the cube of the frequency.</p>
<p>F# lecture notes lecture 3</p>
<p>a program in a fuctional/decarative language defines an expression which is the solution to a set of problems. This expression coprises of the evaultaion of functions whilst avoiding state and mutable data.</p>
<p>In contrast an imprative laguage uses a list of command to be executed in a partucular order where state and mutable data lay the basis for storeing intermeiate and final results.</p>
<p>recusrion is a key contruct in functional languages, recursive calls replace the usual for and while loops from imperative languages.</p>
<p>A few key fetures of f#</p>
<p>1. functions are just another type of value, functions are first class</p>
<p>2. function composistion and pipelining</p>
<p>3. Automatic type inference</p>
<p>4. pattern matching support</p>
<p>5. Recursion</p>
<p>6. Collection types for immutable data</p>
<p>7. lambda expressions.</p>
<p>the let keyword binds an immutble value or function to a symbol/ idetifier. They are different from normal varibles in the following respect. Unless declared mutable they are imutable. They are temporally tied to there value e.g if you define</p>
<p>let a = 10</p>
<p>a + 10</p>
<p>let b = a + 2</p>
<p>whats the value of b?</p>
<p>12 not 22 because</p>
<p>There is also the concept of a partial application, this is where you provide some but not all of the arguments to a function. the result is  a new function which has those arguments set as defaults.  It is for this reason the type signatures in f# are displayed as arrow tereparted lists e.g</p>
<p>let addc inta intb = inta + intb</p>
<p>has the signature</p>
<p>int -&gt; int -&gt; int</p>
<p>the type to the RHS of the final arrow is the return type. All other types represnt the  types of the input arguments . we can make a new let binding as a partial application like</p>
<p>let add5 = addc 5</p>
<p>add5 now has the signature</p>
<p>int -&gt; int because the add5 is the same as addc but with the input argument inta set to 5.</p>
<p>discrimanted unions are like enums witch can be assocaited with data values.  a simple discrimanted union may loop like</p>
<p>type shape =</p>
<p>| Circle</p>
<p>| Square</p>
<p>| Triangle</p>
<p>here circle square and triangle are all given an identifer. Circle, Square and Trianlge become like cases of a Shape enum. they can be matches again with a simple pattern match as follows.</p>
<p>let matchexp s =</p>
<p>match s with</p>
<p>| Circle -&gt; printfn "%s" " hello circle"</p>
<p>| Square -&gt; printfn "%s" "hello square"</p>
<p>| Triangle -&gt; printfn "%s" "hello triangle"</p>
<p>we can call matchexp with a Trignle Circle or Square and the corrosponding function in the match block will be called THey are also more powerful than simple enums in the following reguards.</p>
<p>1. they can contain data. following the identifier name (Circle Square or triangle)  with an of keywork lets you define the data that exsists on the type e.g</p>
<p>type Shape</p>
<p>| Circle of double * double</p>
<p>| Square of double * double * double</p>
<p>| triangle of double * double * string</p>
<p>Fucntional programming is driven by the excuttion of expressions. anything we need to remember is taken with the fucntion through recursion and parameter partseing. imperative langauges have statments which are commands to be executed in a particular order.</p>
<p>Functional languages are closley related to the labmda calculus. They have the advantage of being able to run concurrently and avoiding side effects caused by static varibles/ libaries. Avoiding state and mutable data is a key concept of functional lalnguages.</p>
<p>Optimisation</p>
<p>consider</p>
<p>int foo(int)</p>
<p>int func1 (int x) { return foo(x) + foox(x) + foo(x)}</p>
<p>can we do</p>
<p>int func1 (int x) { return 3*foo(x)}</p>
<p>no if the function body of foo uses statics it may not reurn the same val for each execution even when called on the same input so we can optimise like this. static varibles stay allocated even when the function is popped of the stack</p>
<p>Loop unrolling</p>
<p>Removal of Loop invarients</p>
<p>Removal of costly function calls from loops including loop arguments. using strlen in an for is order n^2 for exaple (in c ) C</p>
<p>Intermeidate code -</p>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">InnProduct</span> <span class="hljs-params">(<span class="hljs-type">float</span> \*A, <span class="hljs-type">float</span> \*B)</span>
</span>{
     <span class="hljs-type">float</span> iprod = <span class="hljs-number">0</span>;
     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i)
     	{
     	iprod += A[i] * B[i];
     	}
    <span class="hljs-keyword">return</span> iprod;
}</code></pre></div>
<p>machine code</p>
<ol>
<li>iprod := 0</li>
<li>i := 0</li>
<li>T1 := 4*i  //step size, cos 1 float is 4 words (bytes) long. will be idx</li>
<li>T2 := addr(A)  // set T2 to the address of A</li>
<li>T3 := T2[T1] // set the its in A to address T1</li>
<li>T4 := addr(B)</li>
<li>T5 := T4[T1]</li>
<li>T6 := T[3] * T[T5]</li>
<li>iprod = iprod + T6</li>
<li>i := i+1</li>
<li>if i&lt; 20 go to (3)</li>
</ol>
<p>optimized vode</p>
<p>we remove the multiplcation and itteration thats done to index each float in addr(A) and addr(B) . we remove these from the loop consisteing of the statements between 3 and 11.</p>
<ol>
<li>iprod = 0</li>
<li>T2 = addr(A) -4 // in the case of the first loop T1=4 after 5 so set back</li>
<li>T4 = addr(B) -4 // in the case of the first loop T1=4 after 5 so set back</li>
<li>T1 = 0</li>
<li>T1 = T1 + 4</li>
<li>T3 = T2[T1]</li>
<li>T5 = T4[T1]</li>
<li>T6 = T3 * T5</li>
<li>iprod = iprod+T6</li>
<li>if T1 &lt;= 76 goto 5 / replaced i*4</li>
</ol>
<p>Example 2</p>
<div><pre class="hljs"><code><span class="hljs-keyword">while</span> ( a &gt; b &amp;&amp; a &lt; <span class="hljs-number">2</span> * b+<span class="hljs-number">1</span> ) a=a+<span class="hljs-number">1</span>;

<span class="hljs-keyword">while</span> ( [<span class="hljs-keyword">id</span>,p1] &gt; [<span class="hljs-keyword">id</span>,p2] &amp;&amp; [<span class="hljs-keyword">id</span>,p1] &lt; [<span class="hljs-keyword">const</span>, p3] * [<span class="hljs-keyword">id</span>,p2] + [<span class="hljs-keyword">const</span>,p4])
[<span class="hljs-keyword">id</span>,p1] = [<span class="hljs-keyword">id</span>,p1] + [<span class="hljs-keyword">const</span>, p4]</code></pre></div>
<p>intermidiate code</p>
<ol>
<li>L1 : if a &gt; b goto L2</li>
<li>goto L3</li>
<li>L:2 T1 := 2*b</li>
<li>T2 := T1 + 1</li>
<li>if a &lt; T2 goto L4</li>
<li>goto L3</li>
<li>L4 : a:= a+1</li>
<li>goto L1</li>
<li>L3<br />
optimized code<br />
// we reverse the condition to save us from calling an additional goto<br />
intermidiate code.</li>
<li>L1 : if a &lt;= b goto L3</li>
<li>L:2 T1 := 2*b</li>
<li>T2 := T1 + 1</li>
<li>if a &gt;= T2 goto L3<br />
6.: a:= a+1</li>
<li>goto L1</li>
<li>L3<br />
because ites executed line by line we can revert the condityion and jump ouit if it isnt met istead of using exxtra gotos.</li>
</ol>
<p>Matrix multiplication can be sped up because to compute the value of a celll in the output, you only need 1 row and 1 colnm of the input. so this row and colunm can be put in shared memory which is more perforrmant than local memory.</p>
<p>AB = [ 1 0 -2      [ 0 3<br />
0 3 -1 ]    -2 -1<br />
0 4]</p>
<p>3+2 * (4 + 7) +3 * 1</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Year1n2Recap]]></title>
            <guid>db556a6964be49c0949253b5a338cd30</guid>
            <pubDate>Thu, 09 Sep 2021 18:18:56 GMT</pubDate>
            <content:encoded><![CDATA[<h1 id="analog-and-digital-electronics">Analog and Digital electronics:</h1>
<ul>
<li>Analog electronics</li>
<li>Laying out circuits</li>
<li>OpAmps 1</li>
<li>OpAmps 2</li>
<li>Communication</li>
<li>Digital electronics</li>
<li>Algebra and Decoders</li>
<li>Memory</li>
<li>State machines</li>
<li>chase erros</li>
</ul>
<h1 id="architechture-and-operating-systems">Architechture and Operating systems</h1>
<ul>
<li>Transistors and logic</li>
<li>Sequential logic</li>
<li>Instruction set architecture, von neuuman architecture</li>
<li>pipeling</li>
<li>System calls, Processes and Threads</li>
<li>Interthread communication and syncronisation</li>
<li>process and thread scheduling</li>
<li>File system managment</li>
<li>Memory managment</li>
<li>Virtual Memory</li>
<li>Page replacment algorithhm</li>
<li>Optimisation</li>
<li>cache</li>
</ul>
<h1 id="datastructures-and-algorithms">Datastructures and Algorithms</h1>
<ul>
<li>Recursion an analysing simple for loops</li>
<li>Bounds and Proofs</li>
<li>Array based list, Link based list, stacks and queues</li>
<li>Quadratic sort, Merge Sort</li>
<li>Quick sort, Specilsed sort</li>
<li>hash tables</li>
<li>trees</li>
<li>tries</li>
<li>binary trees</li>
<li>binary search trees</li>
<li>heaps</li>
<li>graphs</li>
</ul>
<h1 id="networks">Networks</h1>
<ul>
<li>Layerd architecture</li>
<li>higher layers of the OSI model</li>
<li>Mutimedia data</li>
<li>Voice Over IP</li>
<li>Network Securtiy</li>
<li>Transport and Network Layer</li>
<li>Reliable Data Delivery</li>
<li>Data Link Layer</li>
<li>Physical Layer</li>
<li>Network Layer protols : IP and subnets</li>
<li>Network Layer protols : Internet control protocols</li>
<li>Network Layer protols : Routing</li>
<li>Wifi and Mobile networks case study</li>
<li>Network Security</li>
</ul>
<h1 id="programming2">Programming2</h1>
<ul>
<li>The C programming language</li>
<li>Functions, IO and preprocessor directives in C</li>
<li>Structures, ADT's and Systems programming</li>
<li>The C++ programming language</li>
<li>Operator overloading and inheritence</li>
<li>Templates, lambdas and the STL</li>
<li>Java Programming Functors and Iterators</li>
<li>Nested classes , Enum types and lambdas</li>
<li>Number , Serialisation and Reflection</li>
<li>Generics</li>
<li>Collections</li>
<li>Threads</li>
</ul>
<h1 id="softwareengneering">SoftwareEngneering</h1>
<ul>
<li>Requirments</li>
<li>Use cases and Testing</li>
<li>Software Architecture and OO Modelling</li>
<li>Project Managment and Report writing</li>
<li>Design Pattens</li>
<li>JavaFX and Statechart</li>
<li>Static analysis and refactoring</li>
<li>Software Quality, reuse and Product line engineering</li>
</ul>
<h1 id="computing-principals">Computing Principals</h1>
<ul>
<li>set theory</li>
<li>Relations</li>
<li>Functions</li>
<li>Graph Theory</li>
<li>Propositional Logic</li>
<li>Computing with numbers</li>
<li>Formal language theory</li>
</ul>
<h1 id="database-systems">Database Systems</h1>
<ul>
<li>SQL Enviroment</li>
<li>the relational model and relational algebra</li>
<li>SQL I, II, III</li>
<li>Using SQL drivers</li>
<li>ER Modelling</li>
<li>Normalisations</li>
<li>Transactions and Atomic Operations</li>
<li>Recovery</li>
<li>File organisation and query processing</li>
</ul>
<h1 id="programming-1">Programming 1</h1>
<ul>
<li>Intro  to java</li>
<li>Java varibles, constants , and primitive data types</li>
<li>operators and expressions</li>
<li>using objects</li>
<li>problem solving</li>
<li>selection</li>
<li>repititon</li>
<li>Software development</li>
<li>Software Engneering</li>
<li>Static methods</li>
<li>Writing classes</li>
<li>Inrefaces</li>
<li>Arrays and ArrayList</li>
<li>File IO</li>
<li>Introduction to inheritence</li>
<li>UML and further inheritence</li>
<li>Exceptions and Enums</li>
<li>Introduction to DSA</li>
<li>Recursion and java command line args</li>
<li>python</li>
</ul>
<h1 id="systems-development">Systems Development</h1>
<ul>
<li>case studies</li>
<li>requirments</li>
<li>use cases</li>
<li>human computer interface</li>
<li>Secuirty</li>
<li>Building systems, Testing, Quality measurments, Maintainence</li>
<li>projects and project managment</li>
<li>useable security</li>
<li>professional societirs and ethics</li>
</ul>
<h1 id="web-based-programming">Web Based Programming</h1>
<ul>
<li>Intro to HTML</li>
<li>CSS and HTML</li>
<li>HTML Forms</li>
<li>Web Design</li>
<li>Javascript, events, DOM</li>
<li>javascript classes, objects , conditional flow, jquery, anonymous functions</li>
<li>curying, event loops, promises</li>
<li>web server logic, nodejs,npm, fetch, express</li>
<li>CORS, node js REST apis, static file hosting, information delivery (GET/POST) JSON</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ML]]></title>
            <guid>87a19bc21f70424caaafb2b38d254deb</guid>
            <pubDate>Thu, 09 Sep 2021 17:52:02 GMT</pubDate>
            <content:encoded><![CDATA[<p>Lecture 1 -<br />
Machine learning involved building a model from data, the purpouse of the model can be to predict new data or to explore the data through the machine learning algorithms. Consider the data of highrs of men and women</p>
<table>
<thead>
<tr>
<th>Male</th>
<th style="text-align:left">Female</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.8</td>
<td style="text-align:left">1.7</td>
</tr>
<tr>
<td>1.7</td>
<td style="text-align:left">1.8</td>
</tr>
<tr>
<td>1.8</td>
<td style="text-align:left">1.6</td>
</tr>
<tr>
<td>1.6</td>
<td style="text-align:left">1.6</td>
</tr>
<tr>
<td>1.9</td>
<td style="text-align:left">1.5</td>
</tr>
</tbody>
</table>
<p>For the prediction task, a classifier would take the hight of a new person then apply its algorithm to give a result of male or female.</p>
<p>Single Descision Rule Classifier : '<code>if height &gt; x, then male</code><br />
Nearest Neighbour Classifier: <code>find person closest in hight, user there gender</code><br />
some recondite function Classifier <code>f(height) &gt; x, then male</code></p>
<p>considering the single descision rule classifier, the x threshold can be set to any continuous value on the hight axis. When ever its moved a certain proportion of males and females are corectly classified and a propportion ae incorectly classified.  How to we decide what x shoud be. we could use an avaraging funtion like X = (average height ) / sample_size</p>
<p>Brute Force  - try every model ( different values for X ) and select the best. ( can only be used when the search space is small enough)</p>
<p>Grid search - try a sub selection evenly spaced acoss the paramters to ( spllting up the height axis  into N cols and find an X in each and select the best - just brute force will a spaller space.)</p>
<p>Neighbourhood search: start from a single solutioon and iterativly move to nearby solutions until some criteria is met.</p>
<p>Greedy construction - build the model one step at a  time making a tree. (fast but wont allways give an optimal value)</p>
<p>Issues with classification:</p>
<ol>
<li>Generalisation : how well  does the model work on new unseen data</li>
<li>bias varience trade off: how much error is the due to a bad nmodel vs data used to train the  model</li>
<li>overfitting : making a model too complex, so it performs worse on unseen data than the training set. occams razor</li>
<li>Regularisation: a technique to contrain the complexity of a model</li>
</ol>
<p>DataTypes</p>
<p>Varibles like height are continious, there values are Real numbers<br />
Ordinal data is discrete numeric data that has an order like age groups 0-10, 11-20, 21-30 etc<br />
Nominal data is a varible with a dicrete number of values with no order like colour, nationality</p>
<p>Structured data has a physical meaning<br />
Time Series<br />
Text<br />
Images<br />
Audio</p>
<p>Decision Trees.</p>
<p>Quinlan's classic classification example TRAINING DATA</p>
<table>
<thead>
<tr>
<th style="text-align:left">Outlook</th>
<th style="text-align:left">Temp</th>
<th style="text-align:left">Humidity</th>
<th style="text-align:left">windy</th>
<th style="text-align:left">play golf</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">sunny</td>
<td style="text-align:left">high</td>
<td style="text-align:left">high</td>
<td style="text-align:left">weak</td>
<td style="text-align:left">no</td>
</tr>
<tr>
<td style="text-align:left">sunny</td>
<td style="text-align:left">high</td>
<td style="text-align:left">high</td>
<td style="text-align:left">strong</td>
<td style="text-align:left">no</td>
</tr>
<tr>
<td style="text-align:left">overcast</td>
<td style="text-align:left">high</td>
<td style="text-align:left">high</td>
<td style="text-align:left">weak</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">rain</td>
<td style="text-align:left">low</td>
<td style="text-align:left">high</td>
<td style="text-align:left">weak</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">rain</td>
<td style="text-align:left">low</td>
<td style="text-align:left">high</td>
<td style="text-align:left">weak</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">rain</td>
<td style="text-align:left">low</td>
<td style="text-align:left">low</td>
<td style="text-align:left">weak</td>
<td style="text-align:left">no</td>
</tr>
<tr>
<td style="text-align:left">overcast</td>
<td style="text-align:left">low</td>
<td style="text-align:left">low</td>
<td style="text-align:left">strong</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">sunny</td>
<td style="text-align:left">low</td>
<td style="text-align:left">high</td>
<td style="text-align:left">weak</td>
<td style="text-align:left">no</td>
</tr>
<tr>
<td style="text-align:left">sunny</td>
<td style="text-align:left">low</td>
<td style="text-align:left">low</td>
<td style="text-align:left">weak</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">rain</td>
<td style="text-align:left">low</td>
<td style="text-align:left">high</td>
<td style="text-align:left">weak</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">sunny</td>
<td style="text-align:left">low</td>
<td style="text-align:left">low</td>
<td style="text-align:left">weak</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">overcast</td>
<td style="text-align:left">low</td>
<td style="text-align:left">high</td>
<td style="text-align:left">strong</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">overcast</td>
<td style="text-align:left">high</td>
<td style="text-align:left">low</td>
<td style="text-align:left">weak</td>
<td style="text-align:left">no</td>
</tr>
<tr>
<td style="text-align:left">rain</td>
<td style="text-align:left">low</td>
<td style="text-align:left">high</td>
<td style="text-align:left">weak</td>
<td style="text-align:left">yes</td>
</tr>
</tbody>
</table>
<p>Consider the following Descision tree</p>

				<div>
					
					<pre class="mermaid">    graph TD;
    root(what is outlook?)--&gt;Rain(Rain: is it windy);
    root(what is outlook?)--&gt;Sun(Sun: is it humid);
    root(what is outlook?)--&gt;Overcsast[overcast];
    Overcsast --&gt; play1[play golf]
    Sun --&gt; yes1[yes]
    Sun --&gt; no1[no]
    no1 --&gt; play2[play golf]
  yes1 --&gt; dontplay1[Don't play golf]
  Rain --&gt; yes2[yes]
    Rain --&gt; no2[no]
    no2 --&gt; play3[play golf]
  yes2 --&gt; dontplay2[Don't play golf]
</pre>
				</div>
			<p>Any Decission tree can be represneted by a set of rules.</p>
<div><pre class="hljs"><code><span class="hljs-type">if</span> <span class="hljs-variable">outlook</span> <span class="hljs-operator">=</span>sunny
        <span class="hljs-type">if</span> <span class="hljs-variable">humidity</span> <span class="hljs-operator">=</span>low then play=<span class="hljs-literal">true</span>
        <span class="hljs-keyword">else</span> then play=<span class="hljs-literal">false</span>
<span class="hljs-keyword">else</span> <span class="hljs-type">if</span> <span class="hljs-variable">outlook</span> <span class="hljs-operator">=</span>overcast <span class="hljs-type">then</span> <span class="hljs-variable">play</span> <span class="hljs-operator">=</span><span class="hljs-literal">true</span>
<span class="hljs-keyword">else</span> <span class="hljs-type">if</span> <span class="hljs-variable">outlook</span> <span class="hljs-operator">=</span> rain
        <span class="hljs-type">if</span> <span class="hljs-variable">windy</span> <span class="hljs-operator">=</span><span class="hljs-literal">true</span> <span class="hljs-type">then</span> <span class="hljs-variable">play</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>
        <span class="hljs-keyword">else</span> <span class="hljs-type">then</span> <span class="hljs-variable">play</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span></code></pre></div>
<p>we can also generate such trees in the with a Classifier</p>
<p>A descicsion tree is a graphical represneation of an non-overlapping set of rules.<br />
By convention the tree is drawn down the page<br />
The root node is at the top and leaf nodes at the bottom<br />
The tree partitons the input space into disjoint regions represented by leaf nodes</p>
<p>Descision Trees can be used to both analyse relations in the data ( explination) and to pridict new cases.</p>
<p>Descicon trees form the basis of the most popular algorithms ensamble algorithms.</p>
<p>Use a Descsion tree to classify new cases</p>
<ol>
<li>start at the root node</li>
<li>each non-terminal node contains a question</li>
<li>pass instance onto next node according to its data and the nodes question</li>
<li>continue untill a terminal node is reached</li>
<li>the pattern is classified according tto the label of the terminal node.</li>
</ol>
<p>Finding a decision tree from training data using one of the 5 stratergies mentioned.</p>
<p>example greedy algoritm for constucting a solution to the traveling saleman problem.</p>
<ol>
<li>choose a random start city</li>
<li>allways move to the closest unvistied city</li>
</ol>
<p>A greedy algorithm is an algorithm that allways takes the best immidiate or local solution while finding an awnser .<br />
Greedy algorithms work phases. In each phase a decision is made that is the best move locally but without reguard for future consequences.<br />
This genrally means so local minima is found<br />
They are often used when the space of possible solutions is explonetial in nature.</p>
<p>Top Down Induction of Decision Trees</p>
<ol>
<li>If all training examples at this node are classified corectly then stop.</li>
<li>Otherwise, select an attribute as the descicion atrribute to split at the current node (the data will devide between the new spit)</li>
<li>For each value of the attribute create a new child node</li>
<li>split training examples between child nodes</li>
<li>Recursivly apply these steps  to each child node.</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-title">buildTree</span><span class="hljs-params">( DataSet D)</span></span>
    TreeNode t = new TreeNode(D)
<span class="hljs-comment">//Base case: stop building the tree</span>
    <span class="hljs-keyword">if</span>(stoppingCriteria(D))
        t<span class="hljs-selector-class">.setAsLeaf</span>()
        return t
<span class="hljs-comment">//recursive case</span>
<span class="hljs-comment">//1. choose an attribute</span>
    Attribute A  = chooseAttribute(D)
<span class="hljs-comment">//2. split data by attribute</span>
    DataSet<span class="hljs-selector-attr">[]</span> s = splitData(D,A)
    t<span class="hljs-selector-class">.offspring</span> = new TreeNode<span class="hljs-selector-attr">[size(s)]</span>
<span class="hljs-comment">//recursivly call for each split (depth first)</span>
    <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span>:= <span class="hljs-number">1</span> to size(s)
        t,offspring<span class="hljs-selector-attr">[i]</span> = buildTree(s<span class="hljs-selector-attr">[i]</span>)
    return t</code></pre></div>
<h2 id="descision-trees-part-2">Descision trees part 2</h2>
<p>Algorithms for selecting branching attributes</p>
<ol>
<li>information gain</li>
<li>Gini-index</li>
<li>Chi-squared stat</li>
</ol>
<p>Three operations define a TDIDT algorithm</p>
<ol>
<li>
<p>Stopping criteria<br />
When should we stop building the tree, given the data set at any node</p>
</li>
<li>
<p>Choosing an attribute to branch on<br />
This is the important descion</p>
</li>
<li>
<p>how to split the data<br />
For discrete attributes, the easiest solution is to have one cild node for each attribute value</p>
</li>
</ol>
<p>The basic principle of attribute selection is to find the attribute that leads to a branching where the classes are better split up than the parent node. In a pefect split all cases diferentiated by the attribute.There are three commonly used algorithms for assessing how well an attribute splits up a class.</p>
<ol>
<li>Information gain IG : based on shannon's entropy is the basis of early decission trees</li>
<li>GINI impurity. Based on the class probability distrobution. Used in the Breiman's CART familiy of decsion tress.</li>
<li>Chi-Squared: based on the clssic stats test of difference of distrobution. Used in Kass's CHAID decsion trees.</li>
</ol>
<ul>
<li>Claude shannon introduced information theory in 1948.</li>
<li>the key concept in information theory is entropy</li>
<li>entropy measures the unertinty associated with a random varible</li>
<li>consider tossing a coin. If the coin had two heads there is no entropy.</li>
<li>if its a fiar coin there maximum entropy.</li>
<li>if the coin is bias to land on hedas 75% of the time the entropy is somewjere in between. There is information in the squence of coin tosses.</li>
</ul>
<p>Suppose a radom varible X can take c values with probability of that occuring as p(X=i)<br />
The entropy of X is given by the following summation</p>
<div><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mspace linebreak="newline"></mspace><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><munder><mo>∑</mo><mstyle scriptlevel="1"><mtable rowspacing="0.1000em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="1" displaystyle="false"><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mstyle></munder><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><mi>i</mi><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\\
H(X)=-
\sum_{

\begin{subarray}{l}
   i = 1
\end{subarray}}
p(X=i)log2(p(X=i))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mspace" style="margin-right:0.16666666666666666em"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.08125em">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.4536740000000004em;vertical-align:-1.403669em"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em"><span style="top:-1.865163em;margin-left:0em"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66976em"><span style="top:-2.71024em"><span class="pstrut" style="height:2.7em"></span><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.16976em"><span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.0500049999999996em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.403669em"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">i</span><span class="mclose">))</span></span></span></span></span></div>
<p>H provides the lower bound of the minimum number of bits needed to encode the output of x<br />
P(x)=0.5<br />
H(0.5) = 1</p>
<p>P(x) = 1<br />
H(1) = 0</p>
<p>P(x)= 00.75<br />
H(0.75) = 0.81</p>
<p>this entorpy is a measure of how 'pure' a node is.</p>
<p><img src="/_resources/2c2504be8a0441ff95387e223e004c93.PNG" /></p>
<p>Information Gain (IG)</p>
<p>suppose that we need to choose between three attributes that produce the following splits of the train data. We sould choose the split that reducs the entropy the msot, or conversly gives the best infromation gain.</p>
<div><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mi>a</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>−</mo><munder><mo>∑</mo><mstyle scriptlevel="1"><mtable rowspacing="0.1000em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="1" displaystyle="false"><mrow><mi>y</mi><mi>i</mi><mi>n</mi><mi>v</mi></mrow></mstyle></mtd></mtr></mtable></mstyle></munder><mi>y</mi><mi mathvariant="normal">/</mi><mi>x</mi><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Gain(X,A) = H(X) - \sum_{

\begin{subarray}{l}
   yi n v
\end{subarray}}
y/xH(X)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">G</span><span class="mord mathnormal">ain</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.08125em">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:2.463782em;vertical-align:-1.413777em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em"><span style="top:-1.8601089999999998em;margin-left:0em"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6769800000000001em"><span style="top:-2.7174600000000004em"><span class="pstrut" style="height:2.7em"></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">y</span><span class="mord mathnormal mtight">in</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17697999999999997em"><span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.050005em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.413777em"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mord">/</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.08125em">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em">X</span><span class="mclose">)</span></span></span></span></span></div>
<ul>
<li>H(X) is the shannon entropy of the parent node</li>
<li>A is the attribute were assessing</li>
<li>|X| is the number of cases at Node X</li>
<li>|Y| is the number of cases at Node Y<br />
V = {A1,A2...,Ak}</li>
<li>V is the set of Nodes for each k possible values for Attribute A</li>
</ul>
<h2 id="gini-impurity-index">Gini Impurity index</h2>
<h2 id="lecture-5-k-nn-k-nearest-neighbours">Lecture 5 K-nn K nearest neighbours</h2>
<ul>
<li>Knn is one of the oldest ML algorithms proposed by Evelyn Fix and joseph lawson hodge in 1951</li>
<li>Its non probablistic though can estimate posterior probabilities.</li>
<li>k-NN is widly used as a baseline for evaultion</li>
<li>Nearest Neighbour methods are based on a similariety metric, one such Metric is the Euclidian distance.</li>
</ul>
<p>For any given group of objects we must find attributes / features that are most relevant to those objects. e.g for trees we could look at leaf shape. For insects we could look ad abdomen length and antennae length. Plotting these atrribute as axis on a graph, simlar objects will appear in clusters tho this only works when the number of attributes is &lt;=3 . Placing  a new instance on this graph consists on finding the point with the smallest eulidian distance ot another and classifiying it as that class<br />
<img src="/_resources/281f894524404fb79830c608ad3d2447.png" /></p>
<p>NN algorithms can be visulised as a descion surface. implicit boundires deliimit regions withing which every point is closer to one data point that of al others in the set.<br />
Also called a Voronoi diagram.<br />
<img src="/_resources/595f07c836be466792311ad4b1742711.png" /></p>
<ul>
<li>
<p>Rather than looking at the nearest neighbour with euclidian distance look at the labels of k most similar (closest) instances in the train set. A majaority vote of these k points could be used to classifiy new instances.</p>
</li>
<li>
<p>k should be an odd valule so that you never end in a tie.</p>
</li>
<li>
<p>The nerest neghibour 1-NN classifier is purly discrete.</p>
</li>
<li>
<p>The posterior probablilty for the k-NN classifier is p(C|x) = ki/k whre ki is the number of cases in class C.</p>
</li>
<li>
<p>The value of k controls the complexity of the classifier. k is tuned to achieve best genralisation.</p>
</li>
<li>
<p>When k is too small there is overfitting, when k is too large there is under fitting.</p>
</li>
<li>
<p>train from the corpus of data in the knn</p>
</li>
<li>
<p>validation choose the best value for k</p>
</li>
<li>
<p>test, easure the genralisation/performance of the classifier.</p>
</li>
</ul>
<p>Apply cross validation to sample the data for model creation. Split data into V sets of the same size.<br />
Train v classiiers on there respective train set. This creates an ensemble of classifiers.</p>
<p>K-NN is senative to attribute scale values. data should be normalised using (X - mean(X))/std(x)</p>
<p>There are a large number of similarity and distance measures.<br />
<img src="/_resources/d16e77c354c74aa88a0e67393617e317.png" /><br />
k-NN is slow when classifiying new cases due to the linear scan. To speed the process us the cases can be stored in tree data structures, this only helps for a small nubmer of attributes. we can also remove cases not near the boundry region.<br />
Not all cases are required to define a boundry region and indeed some cses my be mis classified.<br />
The more attributes there are the harder it is to remove cases/.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AI]]></title>
            <guid>fa7d579794dd4da58e4ad53c68a0c69c</guid>
            <pubDate>Thu, 09 Sep 2021 17:51:55 GMT</pubDate>
            <content:encoded><![CDATA[<p>From the course below</p>
<ul>
<li><a title="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-034-artificial-intelligence-fall-2010/" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-034-artificial-intelligence-fall-2010/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-034-artificial-intelligence-fall-2010/</a></li>
</ul>
<h1 id="lecture-1-scope">Lecture 1 - scope</h1>
<hr />
<h1 id="lecture-3-tree-traversal">Lecture 3 - Tree traversal</h1>
<hr />
<p>Given a tree where each node has b children and the tree has a depth d then the nuber of nodes is given by<br />
b^d an exponetial relationship. This limits how deep we can go. BFS ensures that any node is found in the minimum number of steps.</p>
<p>DFS doesnt work for genral graphs, they can get stuck in loops in a graph.</p>
<p>DFS is not very costley in memory unlike BFS</p>
<h2 id="lecture-1">Lecture 1</h2>
<hr />
<p>What is AI. AI encompases different methods to get computers to act in an intelligent way. There are two sub problems:</p>
<ol>
<li>Learning and knowledge ccquisition.</li>
<li>Problem solving with 'learned' knowledge</li>
</ol>
<p>AI and include</p>
<ul>
<li>Reasoning and Expert systems</li>
<li>Data Science</li>
<li>Theories and Model based AI</li>
<li>Machine Leanring</li>
<li>Visulations and Actions</li>
</ul>
<p>KR - Knowledge representation How does the machine store infomation for it to act on.</p>
<p>NLP - Natrul Langugae Processing, useful for:</p>
<ul>
<li>Automatic speach recognition</li>
<li>Text document analysis</li>
<li>TTS and STT</li>
<li>dialog systems - chatbots</li>
<li>Machine translation</li>
</ul>
<p>Perception : sound and vision</p>
<ul>
<li>Perception is the ability to scense things in the sourroundings based on sensors.</li>
<li>Speach recognition</li>
<li>Object and face detection.</li>
<li>Image classification</li>
</ul>
<h1 id="lecture-2-basic-state-based-search-methods">Lecture 2 - Basic State Based Search Methods.</h1>
<hr />
<p>State Space Representation</p>
<p>The search method applied to a state space implicitly defines the space. What is state space? What are uninformed search techniques used for searching these spaces. The modeling of the problem defines the state space. These are good for problems with lots of complicated constrains.</p>
<p>Often a solution to a problem is built, step by step from an initial condition.</p>
<p>* the intermidiate configuratiions generated in the construction are called states.</p>
<p>* The initial configuration is called the inital state</p>
<p>* At each step of the construction you perform some operation to transform one state into another.</p>
<p>* Transforming a state using an operation is called a move</p>
<p>* You stop when you have found a state that provides a solution with a desired property. e.g the goal state.</p>
<p>The disfficulty is there can be many alternative choices of operations at each step , and therefore , a considerbly number of possible branches of code execution.Some might be dead ends.</p>
<p>Example 1 (n slideing tile)</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td></td>
<td>8</td>
</tr>
<tr>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>We could slide the right-middle tile Right to make a new state</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>The Initial and Goal states are a certain arrangment of the tiles. Operations swap a tile with an adjacent tile either horizintally or vertically. R L U D are the different directions a tile can move. Some operations can't be used in certain configureations.</p>
<p>It's good to think about moving the empty space instead of the tiles.</p>
<p>The objective is to find a sequence of operations that take you from the inital state to the goal state. And potentialy find the shortest sequence.</p>
<p>It's useful to think of this problem in a state space. A graph where each node is a sate/configuration of the above tiles.</p>
<p>A graph of V={1,2,3} E={(1,2),(1,3)}<br />
would look like:</p>

				<div>
					
					<pre class="mermaid">graph LR
1 --&gt; 2
1 --&gt; 3

</pre>
				</div>
			<p>A tile configuration will be represented by a list containg:</p>
<ul>
<li>The row index i and col index j of the blank tile</li>
<li>the configuration of the tiles as a list of lists where each list within the list repsents a row. The blank tile will be represented by 0.<br />
EG consider</li>
</ul>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td></td>
<td>8</td>
</tr>
<tr>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>could be represented as<br />
[1,1, [2,1,6], [4,0,8], [7,5,3]]</p>
<p>We can represent this in python consider the fucntion:</p>
<div><pre class="hljs"><code><span class="hljs-attribute">def</span> move_blank(i,j,n):
    <span class="hljs-attribute">if</span> i+<span class="hljs-number">1</span> &lt; n:
        <span class="hljs-attribute">yield</span>(i+<span class="hljs-number">1</span>, j)
    <span class="hljs-attribute">if</span> i-<span class="hljs-number">1</span> &gt;=<span class="hljs-number">0</span>:
        <span class="hljs-attribute">yield</span>(i-<span class="hljs-number">1</span>, j)
    <span class="hljs-attribute">if</span> j+<span class="hljs-number">1</span> &lt; n:
        <span class="hljs-attribute">yield</span>(i, j+<span class="hljs-number">1</span>)
    <span class="hljs-attribute">if</span>(j-<span class="hljs-number">1</span> &gt;=<span class="hljs-number">0</span>):
        <span class="hljs-attribute">yield</span>(i, j-<span class="hljs-number">1</span>)
        </code></pre></div>
<p>yield will return the pair of numbers representing the new position of the blank tile. Whats the signifigance of yield. Yield willl return the pair but next time move_blank() is called it will continue from underneath the last yield. You can call this a generator. The state of the original table will be restored after yield.</p>
<p>Example 2 n-queens</p>
<p>Imagine a chess board, we want to plave queens on the chess born so that no queen can attack another. Queens can go any number of blocks up/down / left/right. They can also move diagonally.<br />
We can out mroe than 8 queens on because theres only 8 cols/rows.</p>
<p>A state space for the n queens problem may be defined as follows:</p>
<ul>
<li>A state represents an n x n board on which 0 &lt;= p &lt;= n queens are placed in cols 0,1,2...p-1 so they cannot attack eachother.</li>
<li>The initail state is an empty board.</li>
<li>An operation consists of putting a queen on the first unociupied col such that it cant attack other queens which are allready on the board.</li>
<li>Goal states are states with n queens</li>
</ul>
<p>Yield is like a return but over the next iteration you continue after the yield you last executes. Its a form of iterator. Yield doesnt end the function.</p>
<p>the move function in both examples define the state space. They also capture the rules/relations of the system being modeld.</p>
<p>search methods are impoertant as they allow you to search these search spaces for the next move. They help with state move ordering.</p>
<h2 id="lecture-3">Lecture 3</h2>
<hr />
<p>First we will look at rooted trees, e,g trees where each node has parents apart ftom the node at the top.<br />
In a rooted tree eevery node must have 1 immidiate ancestor apart from the root.</p>
<p>Rooted trees and directed acyclic graphs are search spaces useful for construction problems, where a move consists of adding elements to a set. Construction problems with an acyclic search space include.</p>
<ol>
<li>the 8 queen problem</li>
<li>suduko</li>
<li>the number game in countdown</li>
</ol>
<p>We know we can traverse trees breadth first or depth first. We wont be looking got cycles. This means we can't get back to a state after leaving it.<br />
The main datastructure used to search a rooted tree is a list.</p>
<ul>
<li>OPEN : List of states that have been generated but not expanded.</li>
<li>BFS - In this case open is a queue i.e a FIFO structure.</li>
<li>DFS - in this case open is a stack e.g LIFO</li>
</ul>
<p>In BFS the nodes are explored in non-decreasing distance (in the number of arcs/edges) from the root node. E.g from the root node, look at all nodes in layer 1, then 2 then 3 etc. When looking at nodes in a layer look left to right.</p>
<p>In DFS we go from the root node to down the layers to the bottom layers and work up going right to left.</p>
<p>BFS gurantees that a closest goal (in the number of moves) is found.</p>
<p>BFS works for any state space e.g genral class tho it may re-examine some states.<br />
DFS doesnt work for cyclic graphs as you can get stuck in a loop.</p>
<p>up to ai 4 lecture. + labsheet 2</p>
<h2 id="lecture-4">Lecture 4</h2>
<hr />
<p>Best-First Search</p>
<p>The search space is defined as follows.</p>
<ul>
<li>A state n iis a path from T to some city. f(n) is the length of this path.</li>
</ul>
<p>##Lecture 5</p>
<p>min aung ai types</p>
<p>Action Schema</p>
<ul>
<li>Actions are described A set of action schemas which define Actions(s) abnd Results(s,a)</li>
</ul>
<p>Action(Fly(p,from,to))<br />
Precond At(p,from) and At()</p>
<h2 id="lecture-5-state-space-search">Lecture 5 - State Space Search</h2>
<hr />
<p>State space search optimisation problems.</p>
<ul>
<li>Optimisation problems</li>
<li>state representation</li>
<li>binary search</li>
<li>best-first seaach</li>
<li>a star</li>
<li>proof of a*</li>
<li>IDA*</li>
</ul>
<p>Our goal is to find a state that minimises some function. Taking the nubmers game from countdown as an example: The rules are :</p>
<ul>
<li>select 6 numbered tiles, big or small values.</li>
<li>a three digit random number is generated.</li>
<li>The objective is to get as close to the awnser using each tile at more more than once each and * + - / operators are allowd.</li>
</ul>
<p>The states may be represented by a list of arithmetic expressions. The inital step is a set of 6 numbers.</p>
<p>A move operation is defined as taking two numbers from the list, combinging them in an arithmetic operation and putting the result at the end of the list.</p>
<p>A Goal is a state where the element in the head of the list is as close as possible to the target number. 2</p>
<p>We can use binary search to speed up searching the state space for a suitable awnser. A pass amounts to searching for a solution such that abs(target - solution) &lt;= (low + high) /2 where low and high are the highest number at the head of the list and the lowest number in the head of the list.</p>
<p>Each pass is solved using IDDFS (Iterative Deepening Depth First Search)</p>
<p>The initial value of high is set to 999 as this is the highest posible 3 digigt number we can make. We do not need to store the path because only the first element in the headof a list is what we are intrested in. We do not need to test for cycling paths.</p>
<p>We call the function that searches all the state spaces f(x). The minimul value of the function is 0 while the maxium is 999.<br />
Best First Search in a genral search algorithm that searches a state space by explanding states , n, in a non decreasing order of a cost function f(n).</p>
<p>Modified cases of best first search include</p>
<ul>
<li>Dijkstras algorithm. Where f(n) is the sum of arc costs along the path from the start node to node n.</li>
<li>BFS where f(n) is simply the sum of the number of arcs from the start node to node n.</li>
<li>A* f(n) also takes in to account an estimate of the cost of reaching a goal from node n.</li>
</ul>
<p>For BFS we use a prioirty queue. BFS applied to finding the shortest path bewtween two nodes. We retrive the node to exapand in order of value.</p>
<p><img src="/_resources/b70ba1c760bb4656a5734c29a13c0a2e.PNG" /></p>
<p>That means the first node we expland is G.yarmouth and the value for f(n) for Norwihch to G.Yarmouth is smaller than too any of the other edges comeing from norwich. However we can also see it makes a longer path to kings lynn. How to we fix this.</p>
<p>The state space is modeld as follows:</p>
<ul>
<li>A state n is a path from T to some city. f(n) is the length of path n.</li>
<li>The initial state is a path with a single node T.</li>
<li>A move is the extension of a path ,n, by one leg. The cost of a move is c. The f(n) of the new path is f(n)+c</li>
<li>A path is a goal state if it connects T to Kings lynn</li>
<li>The first goal state found by best first search. It is exapanded down the smalles cost/ leg.</li>
</ul>
<p>Best first search will search all paths before searching for the shortest. It does not have a scence of direction. We can use the A* algorithm to give it a notion of what direction to go in.</p>
<p>An algorithm that directs the search towards promising regions of the search space. These algorithms use a evalutation functions to estimate the likly hood that a given node is on the shortest path. A* is one such algorithm, whith some asumptions made A* will return the optimal solution.</p>
<p>A* applied to the n tile problem where:</p>
<div><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = g(n) + h(n)

</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></div>
<p>where g(n) is the length of the path (or nubmer of operations) in the search tree from the start to the node n.<br />
and h(n) is the number of misplaces tiles in the discription associated with n. i.e the number of tiles that are not at the same position in the current discription and the goal discription.</p>
<p>f(n) becomes out evaulation function. h(n) here is apoximatly the number of moves left.</p>
<p>When is A* optimal. An estimation function h(n) is admissable if for every state n , 0 &lt;= h(n) &lt;= h*(n) where h*(n) is the lower bound on the number of moves to go to a goal from n.<br />
Ad addmissable hueristic never overestimates the coast to reach a goal.<br />
if h is admissable the solution returned by A* is a goal with the smallest g value.</p>
<p>When a state is explanded in BFS its placed in CLOSED and never expanded again e.g never placed in OPEN again.<br />
The property of admissability does not gurarntee that a state placesd in CLOSE does not need to be re-examinded.<br />
Hoewver if h is based on a distance function i.e h(n) = d(n,t) where t is the goal state then a state placed in closed deosnt need to be examind again.</p>
<p>A distance function is a dfucntion that computes a distance. Consider a set of objects {o1,o2,o3,o4}. if a function distance function obeys the rules</p>
<div><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>o</mi><mn>1</mn><mo separator="true">,</mo><mi>o</mi><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d(o1,o1)  = 0

</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal">o</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">0</span></span></span></span></span></div>
<div><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>o</mi><mn>1</mn><mo separator="true">,</mo><mi>o</mi><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mi>d</mi><mo stretchy="false">(</mo><mi>o</mi><mn>2</mn><mo separator="true">,</mo><mi>o</mi><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d(o1,o2) = d(o2,o1)

</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal">o</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal">o</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></div>
<div><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>o</mi><mn>1</mn><mo separator="true">,</mo><mi>o</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mo stretchy="false">(</mo><mi>o</mi><mn>2</mn><mo separator="true">,</mo><mi>o</mi><mn>3</mn><mo stretchy="false">)</mo><mo>&gt;</mo><mo>=</mo><mi>d</mi><mo stretchy="false">(</mo><mi>o</mi><mn>1</mn><mo separator="true">,</mo><mi>o</mi><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d(o1,o2) + d(o2,o3) &gt;= d(o1,o3)

</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal">o</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal">o</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal">o</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span></div>
<p>Obeying these rules means someting obeys the triangular inequality.</p>
<p>An estinmate function is consistant if</p>
<div><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>−</mo><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mo>=</mo><mi>k</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(m) -h(n) &lt;= k(m,n)

</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></div>
<p>for all m,n where k(m,n) is the length of the shortest path between m and n.</p>
<p>UNder the consistency assumption when A* inserts a node into CLOSED a shortesst path to that node has been found.</p>
<h2 id="interative-deepening-a">Interative Deepening A*</h2>
<ul>
<li>A pass consists of explanding all nodes that have an f value less than or equal to a bound.</li>
<li>The initial bound is the f value of the start state</li>
<li>The next bound is the smallest f value of the start states generated in the searc but not expanded</li>
<li>workds fine for f increasing along the search path (monotonic)</li>
</ul>
<p>Problem reduction represenetation.</p>
<h1 id="lecture-6-expert-systems-reasoning-methods">Lecture 6 - Expert Systems &amp; Reasoning Methods</h1>
<hr />
<p>Aims and Objectives</p>
<ul>
<li>learn basic methods of knowledge representation</li>
<li>expert systems</li>
<li>rule based reasoning</li>
<li>case based reasoning</li>
<li>model based reasoning</li>
</ul>
<p>What is AI, Data, Information ,Raw facts, Knowledge??<br />
Computers solving problems in a sinmlar way to humans.</p>
<p>Data can be pasrsed into a more useful format creating information. Knowledge - facts information and skills aqquired through experience or education.</p>
<p>Knowleedge represntation - KR<br />
the presrestation od knowledge that enables AI's to solve real world problems. A sucsessful knowledgee representation should be understable by humans and machines. It should be able to make an AI reason and behave like is has knowledge.</p>
<p>KR methods</p>
<ul>
<li>propositional logic - classic</li>
<li>predicate logic - classic</li>
<li>scripts - classic</li>
<li>rules - classic</li>
<li>frames</li>
<li>semantic nets</li>
<li>conceptual graphs</li>
<li>OOM and XML</li>
<li>ontology and web ontology language.</li>
</ul>
<p>production ruels consist of condition-action pairs. they have an If Then Else structure.</p>
<p>A frame is a datastructure used to represent knowledge of a particular concept. roughly equivlent to the OO paradigm. Frames are a machine-useable formalisation of concepts or schemata.</p>
<p>Production Rules PR<br />
Working Memory WM<br />
Recognise Act Engine RAE</p>
<p>M model based system uses a mathmatical model that represents the structure and behaviours of the problem.device to do resoning.</p>
<p>Commonly used in diagnosis of equipment malfuctions<br />
Problems that can be well understood by mathmatical models.</p>
<p>The expert system prdicts diagnosis based off discrpenecny between observed data and what a model pridicts.</p>
<h1 id="lecture-8-gpu-progrmming-continued">lecture 8 GPU progrmming continued</h1>
<p>CUDA and OpenCL.</p>
<p>Summing two matracies of the same dimensions results a theird matrix of the same size. Each individual element wise addition could be done in paralel. Cuda has a hierarchy of threads. For a 2d problem like this we can use a 2d array of threads. We need to think about how we can break down our problem into blocks of CUDA threads. Block index and Block Dimnesion.</p>
<div><pre class="hljs"><code>__global__ void <span class="hljs-constructor">MatAdd(<span class="hljs-params">float</span> <span class="hljs-operator">*</span><span class="hljs-params">a</span>, <span class="hljs-params">float</span><span class="hljs-operator">*</span> <span class="hljs-params">b</span>, <span class="hljs-params">float</span> <span class="hljs-operator">*</span><span class="hljs-params">c</span>, <span class="hljs-params">int</span> N)</span></code></pre></div>
<h2 id="lecture-7-baysian-networks-for-reasoning-form-week-by-end-of-week">Lecture 7 - Baysian Networks for reasoning. - form week by end of week</h2>
<p>Sources of uncertintity</p>
<ul>
<li>Incompletness - unknown values</li>
<li>Incorectness - wrong / misleading data</li>
<li>Inconsistency - contratditions</li>
<li>Dynamics - information maay vary of time</li>
<li>Too much information</li>
</ul>
<p>How can we compensate for these sources of uncertity. We need a system that can</p>
<ul>
<li>
<p>Compensate for lack of knowledge</p>
</li>
<li>
<p>resolve ambiguites and contraditions</p>
</li>
<li>
<p>Update the knowledge known to the system</p>
</li>
<li>
<p>Probablistic reasoning - using a basian network</p>
</li>
<li>
<p>Default reasoning - reasoning by some common sense rules.</p>
</li>
<li>
<p>Dempster-Shafer theory - using a belief function that quatifies difference between uncertenties you may have.</p>
</li>
<li>
<p>Fuzzy logic dealing with vauge mbiguous values.</p>
</li>
<li>
<p>Prior (or before) something exisists before we observe any evidence of a partticular event.</p>
</li>
<li>
<p>Posterior something happened after we had observed something</p>
</li>
<li>
<p>Unconitional proability - irrspectivie of other conditions</p>
</li>
<li>
<p>conditional probability - respective of priors</p>
</li>
<li>
<p>joint probability - two or more events occuring simulataneosly</p>
</li>
<li>
<p>Evidence - something that has happened, an observation</p>
</li>
</ul>
<p>P(A) the prioir probability that event A happens<br />
P(A | B) the posterioir probability of A happeneing given B happened.<br />
here P(B) is the 'evidence' that P(A) will happen.</p>
<p>useful for diagnostic reasoning. e,g<br />
P(cause | effect) = P(effect | cause) * P(cause) / P(effect)<br />
P(flu | fever) - probaiblity of having the flu, given somsone has a fever.</p>
<p>In the real wolrd we have more than one possible events that could happen.<br />
Tha basysian updating rule: If a new evidence C emerged, then baysian theroum can using it to cauluclate the probability of A occuring gievn event B and C</p>
<div><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>B</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>P</mi><mo stretchy="false">(</mo><mi>C</mi><mi mathvariant="normal">∣</mi><mi>B</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>P</mi><mo stretchy="false">(</mo><mi>C</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A | B, C) =P(A, B ,C) / P(B,C) = P(A|B)*P(C| B,A)/P(C|A)

</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span></span></div>
<p>We arrive at this formula using chain rule.</p>
<h2 id="independence">Independence</h2>
<p>Events are indpendedt if P(A | B) == P(A) and P(B | A) == P(B)<br />
aka events A and B have no bearing on eachother.</p>
<p>We can calulate the joint probability (the probability bot events happen) by multiplying them.<br />
P(A,B) = P(A | B)P(B) = P(A)*P(B)</p>
<p>Conditional Independence:<br />
Under some conditions some events might be indpened from eachother. Imagine A bian coin that lands of heads 0.7 of the time. Consider A as the first toll and B as the second.<br />
A and B are not indpenedent as A has information about the coin. A is more likly to be heads.</p>
<p>Baysian (Belife) Network<br />
If we have a good representation of our problem and the varibles it concerns we can create a directed graph for reasoning under uncertity. A Baysian Network is a directed graph for reasoning.</p>
<ul>
<li>to represent conditional independence between vaibles</li>
<li>to specify full joint probability distrocution<br />
Also known as</li>
<li>Belief network</li>
<li>proabilistic network</li>
<li>Casual Networks</li>
</ul>
<p>We update the piriors in a basysian network based on the evidence we are given. Propogation:</p>
<ul>
<li>Infere the probability of a node S in the belief network bt indirectly using the new evidence entered by a different node R that is not directly joined to S by a edge in the undirected graph.</li>
</ul>
<p>Casual reasoning or pridictive reasoning is to infere top down effectes.</p>
<p>Common sense reasoning can pdate itself with new rules that can contradict the old ones. The machine must be permitted to make tentative or deafult reasoning about things.</p>
<p>week 9</p>
]]></content:encoded>
        </item>
    </channel>
</rss>